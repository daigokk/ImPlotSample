# 2.3. FFT

## 1. FFTってなに？
- **高速フーリエ変換**のこと。信号処理や周波数解析(スペクトル解析)など、電気系の分野でよく使われます。
- **バラフライ演算**と再帰演算により、高速に周波数解析が可能です。

![Hard copy](./images/signal_fft_01.png)

---

## 2. サンプルプログラム

```cpp
void fft(std::vector<std::complex<double>>& a) {
    int N = a.size();
    if (N <= 1) return;

    // 偶数・奇数に分割 配列のサイズが半分になる！！！
    std::vector<std::complex<double>> even(N / 2), odd(N / 2);
    for (int i = 0; i < N / 2; ++i) {
        even[i] = a[i * 2];
        odd[i] = a[i * 2 + 1];
    }

    // 再帰呼び出し
    fft(even);
    fft(odd);

    // 合成: バラフライ演算
    for (int k = 0; k < N / 2; ++k) {
        std::complex<double> t = std::polar(1.0, -2 * PI * k / N) * odd[k];
        a[k] = even[k] + t;
        a[k + N / 2] = even[k] - t;
    }
}
```
- 6行目の`std::vector<std::complex<double>> even(N / 2), odd(N / 2);`から、入力データ`a`のサイズが2のべき乗であることを期待していることがわかります。なぜなら奇数だと値が失われてしまうからです。
- `std::vector<>`は任意の型の可変長配列を作ることができる、とても便利(例えば、プログラムの途中で配列のサイズを変える、関数に配列とそのサイズを一つの引数で渡すことができる、等)なC++の機能の一つです。
- 13行目で自分自身(`fft`)を呼び出しています。これを**再帰呼び出し**と言います。このような関数を再帰関数と呼びます。
- 最後の`for`ブロックのバラフライ演算とは、`even[k]`と`odd[k]`を使って、回転因子`std::polar(1.0, -2πk/N)`を掛けて、加算と減算で結果を合成しているところを指しています。この「加算・減算・回転因子」の組み合わせが、バタフライの形に似てると言われています。polar関数は複素数を極形式で指定して作る関数です。
  ```
  even[k] ──┐        ┌── a[k]
            ├─ 加算 ─┤
  odd[k]  ──┘        └── a[k + N/2]
  ```

---

## 3. 注意点

- 入力データのサイズは2のべき乗でなければいけない。
- FFTの出力は複素数。じつは入力も複素数。今回の入力は虚数成分が0の複素数を用いている。
- FFTは信号が周期的であると仮定して解析するため、両端の値が不連続だと不備がある(どのような？)。
- 出力データの振幅は元のデータより小さくなっているように見える。つまり振幅を求めるには補正が必要(どのような？)。ただしDC成分(両端)とナイキスト成分(真ん中)は補正をせずにそのまま用いる。
- FFT結果は左右(配列前半と後半が)対称になるため、周波数分析に使うのは前半だけ。

---

## 4. レポート課題

1. 逆FFTは周波数スペクトルを入力すると波形を出力します。FFTと逆FFTのコードの違いを指摘してください。
   - 加点例: FFTに周波数スペクトルをの入力したときの出力と比較する。
1. 入力データの両端の値が不連続(入力データが測定波形の周期で割り切れない)の場合、どのような影響(どのようなノイズ)が出るでしょうか？
  - 加点例: ノイズを軽減するWindow関数について調べる。
1. 入力データのサイズを2のべき乗に限定せず、任意とするための方法を提案してください。
   - 加点例: 提案を実装する。

- 逆FFT
    ```cpp
    void ifft(std::vector<std::complex<double>>& a) {
        int N = a.size();
        if (N <= 1) return;
    
        // 偶数・奇数に分割
        std::vector<std::complex<double>> even(N / 2), odd(N / 2);
        for (int i = 0; i < N / 2; ++i) {
            even[i] = a[i * 2];
            odd[i]  = a[i * 2 + 1];
        }
    
        // 再帰呼び出し
        ifft(even);
        ifft(odd);
    
        // 合成（回転因子polarの引数の符号が正）
        for (int k = 0; k < N / 2; ++k) {
            std::complex<double> t = std::polar(1.0, 2 * PI * k / N) * odd[k];
            a[k]       = even[k] + t;
            a[k + N/2] = even[k] - t;
        }
    
        // スケーリング（1/N）
        if (N == a.size()) {
            for (int i = 0; i < N; ++i) {
                a[i] /= N;
            }
        }
    }
    ```
